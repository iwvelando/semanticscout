"""
Reporting module for Semantic Scout.

Generates daily markdown summaries and reports for high-scoring job listings.
Supports output to local files and Slack notifications.
"""

import logging
from datetime import datetime, timedelta
from pathlib import Path
from typing import Optional

import httpx

from .config import ReportingConfig, SlackConfig
from .database import Database, Job, ApplicationStatus

logger = logging.getLogger(__name__)


class ReportGenerator:
    """Generates markdown reports for job listings."""
    
    def __init__(self, config: ReportingConfig, database: Database):
        """
        Initialize the report generator.
        
        Args:
            config: Reporting configuration.
            database: Database instance.
        """
        self.config = config
        self.db = database
        self.output_dir = Path(config.output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        logger.info(f"Report generator initialized, output dir: {self.output_dir}")
    
    def generate_daily_report(
        self, 
        date: Optional[datetime] = None,
    ) -> str:
        """
        Generate a daily summary report.
        
        Args:
            date: The date to report on (defaults to today).
        
        Returns:
            The markdown report content.
        """
        if date is None:
            date = datetime.now()
        
        # Get start of day
        start_of_day = date.replace(hour=0, minute=0, second=0, microsecond=0)
        
        # Get high-scoring jobs from today
        jobs = self.db.get_jobs_by_score_threshold(
            min_score=self.config.min_score_threshold,
            since=start_of_day
        )
        
        # Generate report
        report = self._build_daily_report(jobs, date)
        
        # Save to file if configured
        if self.config.save_to_file:
            filename = f"daily_report_{date.strftime('%Y-%m-%d')}.md"
            filepath = self.output_dir / filename
            
            with open(filepath, 'w') as f:
                f.write(report)
            
            logger.info(f"Daily report saved to: {filepath}")
        
        # Send to Slack if configured
        if self.config.slack.enabled:
            self._send_to_slack(report, jobs, date)
        
        return report
    
    def _build_daily_report(self, jobs: list[Job], date: datetime) -> str:
        """
        Build the markdown content for a daily report.
        
        Args:
            jobs: List of high-scoring jobs.
            date: The report date.
        
        Returns:
            Markdown formatted report.
        """
        lines = [
            f"# Semantic Scout Daily Report",
            f"",
            f"**Date:** {date.strftime('%B %d, %Y')}",
            f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"",
            f"---",
            f"",
            f"## Summary",
            f"",
            f"- **High-scoring jobs found:** {len(jobs)}",
            f"- **Minimum score threshold:** {self.config.min_score_threshold}",
            f"",
        ]
        
        if not jobs:
            lines.extend([
                "No jobs scoring above the threshold were found today.",
                ""
            ])
        else:
            # Add statistics
            avg_score = sum(j.semantic_score or 0 for j in jobs) / len(jobs)
            remote_count = sum(1 for j in jobs if j.is_remote)
            
            lines.extend([
                f"- **Average score:** {avg_score:.1f}",
                f"- **Remote positions:** {remote_count}",
                f"",
                "---",
                "",
                "## Top Opportunities",
                "",
            ])
            
            # Sort by score descending
            sorted_jobs = sorted(jobs, key=lambda j: j.semantic_score or 0, reverse=True)
            
            for i, job in enumerate(sorted_jobs, 1):
                lines.extend(self._format_job_entry(job, i))
        
        # Add database stats
        stats = self.db.get_stats()
        lines.extend([
            "---",
            "",
            "## Database Statistics",
            "",
            f"- **Total jobs tracked:** {stats['total_jobs']}",
            f"- **Jobs scored:** {stats['scored_jobs']}",
            f"- **High-scoring jobs (all time):** {stats['high_scoring_jobs']}",
            "",
        ])
        
        if stats.get('average_score'):
            lines.append(f"- **Average score (all jobs):** {stats['average_score']}")
        
        lines.extend([
            "",
            "---",
            "",
            "*Generated by Semantic Scout*",
        ])
        
        return '\n'.join(lines)
    
    def _format_job_entry(self, job: Job, index: int) -> list[str]:
        """
        Format a single job entry for the report.
        
        Args:
            job: The job to format.
            index: The job number in the list.
        
        Returns:
            List of markdown lines.
        """
        lines = [
            f"### {index}. {job.title}",
            f"",
            f"| Field | Value |",
            f"|-------|-------|",
            f"| **Company** | {job.company} |",
            f"| **Location** | {job.location} |",
            f"| **Score** | **{job.semantic_score:.1f}/10** |",
            f"| **Source** | {job.source.title()} |",
        ]
        
        # Add matched city / geo info
        if job.matched_city:
            if job.matched_city == "Remote":
                lines.append(f"| **Matched** | ðŸ  Remote |")
            elif job.matched_city == "Anywhere":
                lines.append(f"| **Matched** | ðŸŒ Anywhere (geo filter disabled) |")
            else:
                distance_str = f" ({job.distance_miles:.1f} mi)" if job.distance_miles else ""
                lines.append(f"| **Matched** | ðŸ“ {job.matched_city}{distance_str} |")
        elif job.is_remote:
            lines.append(f"| **Remote** | âœ… Yes |")
        elif job.distance_miles is not None:
            lines.append(f"| **Distance** | {job.distance_miles:.1f} miles |")
        
        lines.append(f"| **Status** | {job.application_status.value.title()} |")
        
        if job.url:
            lines.append(f"| **Link** | [View Job]({job.url}) |")
        
        lines.append("")
        
        # Add reasoning
        if job.score_reasoning:
            lines.extend([
                "**AI Assessment:**",
                f"> {job.score_reasoning}",
                "",
            ])
        
        # Add description if configured
        if self.config.include_job_descriptions and job.description:
            # Truncate long descriptions
            desc = job.description[:1000]
            if len(job.description) > 1000:
                desc += "..."
            
            lines.extend([
                "<details>",
                "<summary>ðŸ“„ Job Description</summary>",
                "",
                desc,
                "",
                "</details>",
                "",
            ])
        
        lines.append("")
        return lines
    
    def generate_weekly_summary(
        self, 
        end_date: Optional[datetime] = None,
        save_to_file: bool = True
    ) -> str:
        """
        Generate a weekly summary report.
        
        Args:
            end_date: The end date of the week (defaults to today).
            save_to_file: Whether to save the report to a file.
        
        Returns:
            The markdown report content.
        """
        if end_date is None:
            end_date = datetime.now()
        
        start_date = end_date - timedelta(days=7)
        
        # Get all high-scoring jobs from the week
        jobs = self.db.get_jobs_by_score_threshold(
            min_score=self.config.min_score_threshold,
            since=start_date
        )
        
        lines = [
            f"# Semantic Scout Weekly Summary",
            f"",
            f"**Period:** {start_date.strftime('%B %d')} - {end_date.strftime('%B %d, %Y')}",
            f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"",
            "---",
            "",
            "## Weekly Overview",
            "",
            f"- **High-scoring opportunities:** {len(jobs)}",
        ]
        
        if jobs:
            avg_score = sum(j.semantic_score or 0 for j in jobs) / len(jobs)
            top_score = max(j.semantic_score or 0 for j in jobs)
            remote_count = sum(1 for j in jobs if j.is_remote)
            
            # Count by source
            by_source = {}
            for job in jobs:
                by_source[job.source] = by_source.get(job.source, 0) + 1
            
            lines.extend([
                f"- **Average score:** {avg_score:.1f}",
                f"- **Top score:** {top_score:.1f}",
                f"- **Remote positions:** {remote_count}",
                "",
                "### By Source",
                "",
            ])
            
            for source, count in sorted(by_source.items(), key=lambda x: -x[1]):
                lines.append(f"- **{source.title()}:** {count}")
            
            lines.extend([
                "",
                "---",
                "",
                "## Top 10 Opportunities",
                "",
            ])
            
            # Show top 10
            sorted_jobs = sorted(jobs, key=lambda j: j.semantic_score or 0, reverse=True)[:10]
            
            for i, job in enumerate(sorted_jobs, 1):
                score = job.semantic_score or 0
                remote_badge = " ðŸ " if job.is_remote else ""
                lines.append(
                    f"{i}. **{job.title}** at {job.company} - "
                    f"Score: {score:.1f}/10{remote_badge} "
                    f"([Link]({job.url}))"
                )
            
        else:
            lines.append("")
            lines.append("No high-scoring jobs found this week.")
        
        lines.extend([
            "",
            "---",
            "",
            "*Generated by Semantic Scout*",
        ])
        
        report = '\n'.join(lines)
        
        if save_to_file:
            filename = f"weekly_summary_{end_date.strftime('%Y-%m-%d')}.md"
            filepath = self.output_dir / filename
            
            with open(filepath, 'w') as f:
                f.write(report)
            
            logger.info(f"Weekly summary saved to: {filepath}")
        
        return report
    
    def generate_application_tracker(self, save_to_file: bool = True) -> str:
        """
        Generate a report tracking application status.
        
        Args:
            save_to_file: Whether to save the report to a file.
        
        Returns:
            The markdown report content.
        """
        lines = [
            "# Job Application Tracker",
            "",
            f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            "",
            "---",
            "",
        ]
        
        # Get jobs by status
        status_order = [
            ApplicationStatus.APPLIED,
            ApplicationStatus.INTERVIEWING,
            ApplicationStatus.OFFER,
            ApplicationStatus.REVIEWED,
            ApplicationStatus.NEW,
            ApplicationStatus.REJECTED,
            ApplicationStatus.DECLINED,
            ApplicationStatus.ACCEPTED,
        ]
        
        for status in status_order:
            jobs = self.db.get_all_jobs(status=status, limit=100)
            
            if jobs:
                emoji = {
                    ApplicationStatus.NEW: "ðŸ†•",
                    ApplicationStatus.REVIEWED: "ðŸ‘€",
                    ApplicationStatus.APPLIED: "ðŸ“¤",
                    ApplicationStatus.INTERVIEWING: "ðŸŽ¤",
                    ApplicationStatus.OFFER: "ðŸŽ‰",
                    ApplicationStatus.REJECTED: "âŒ",
                    ApplicationStatus.DECLINED: "ðŸš«",
                    ApplicationStatus.ACCEPTED: "âœ…",
                }.get(status, "ðŸ“‹")
                
                lines.extend([
                    f"## {emoji} {status.value.title()} ({len(jobs)})",
                    "",
                ])
                
                for job in jobs:
                    score_str = f"{job.semantic_score:.1f}" if job.semantic_score else "N/A"
                    lines.append(
                        f"- **{job.title}** at {job.company} (Score: {score_str})"
                    )
                
                lines.append("")
        
        lines.extend([
            "---",
            "",
            "*Generated by Semantic Scout*",
        ])
        
        report = '\n'.join(lines)
        
        if save_to_file:
            filename = "application_tracker.md"
            filepath = self.output_dir / filename
            
            with open(filepath, 'w') as f:
                f.write(report)
            
            logger.info(f"Application tracker saved to: {filepath}")
        
        return report
    
    def print_summary(self, jobs: list[Job]) -> None:
        """
        Print a quick summary to console.
        
        Args:
            jobs: List of jobs to summarize.
        """
        print("\n" + "=" * 60)
        print("SEMANTIC SCOUT - HIGH SCORING OPPORTUNITIES")
        print("=" * 60)
        
        if not jobs:
            print("\nNo high-scoring jobs found.")
            return
        
        print(f"\nFound {len(jobs)} jobs scoring >= {self.config.min_score_threshold}\n")
        
        sorted_jobs = sorted(jobs, key=lambda j: j.semantic_score or 0, reverse=True)
        
        for i, job in enumerate(sorted_jobs[:10], 1):
            score = job.semantic_score or 0
            remote = " [REMOTE]" if job.is_remote else ""
            print(f"{i}. [{score:.1f}] {job.title}")
            print(f"   ðŸ“ {job.company} - {job.location}{remote}")
            if job.score_reasoning:
                print(f"   ðŸ’¡ {job.score_reasoning[:80]}...")
            print()
        
        if len(jobs) > 10:
            print(f"... and {len(jobs) - 10} more. See the full report for details.")
        
        print("=" * 60 + "\n")
    
    # =========================================================================
    # Slack Integration
    # =========================================================================
    
    def _send_to_slack(
        self, 
        report: str, 
        jobs: list[Job], 
        date: datetime
    ) -> bool:
        """
        Send report to Slack.
        
        Uses webhook for simple messages, or bot token for file uploads.
        
        Args:
            report: The full markdown report.
            jobs: List of jobs in the report.
            date: The report date.
        
        Returns:
            True if successful, False otherwise.
        """
        slack_config = self.config.slack
        
        try:
            if slack_config.bot_token and slack_config.channel_id:
                # Use bot token for file upload
                return self._send_slack_with_bot(report, jobs, date)
            elif slack_config.webhook_url:
                # Use webhook for message only
                return self._send_slack_webhook(jobs, date)
            else:
                logger.warning(
                    "Slack is enabled but no webhook_url or bot_token configured"
                )
                return False
                
        except Exception as e:
            logger.error(f"Failed to send Slack notification: {e}")
            return False
    
    def _send_slack_webhook(self, jobs: list[Job], date: datetime) -> bool:
        """
        Send a summary message via Slack webhook.
        
        Note: Webhooks cannot use threading or upload files.
        Shows summary with top 5 jobs inline.
        
        Args:
            jobs: List of jobs in the report.
            date: The report date.
        
        Returns:
            True if successful.
        """
        slack_config = self.config.slack
        
        # Build the message - use summary blocks with inline top jobs
        blocks = self._build_slack_webhook_blocks(jobs, date)
        
        # Add mentions if configured
        text = self._build_mention_text(jobs, date)
        
        payload = {
            "text": text,
            "blocks": blocks,
        }
        
        with httpx.Client(timeout=30.0) as client:
            response = client.post(
                slack_config.webhook_url,
                json=payload,
            )
            
            if response.status_code == 200:
                logger.info("Slack webhook notification sent successfully")
                return True
            else:
                logger.error(
                    f"Slack webhook failed: {response.status_code} - {response.text}"
                )
                return False
    
    def _build_slack_webhook_blocks(
        self, 
        jobs: list[Job], 
        date: datetime
    ) -> list[dict]:
        """
        Build Slack blocks for webhook (includes top 5 inline since no threading).
        
        Args:
            jobs: List of jobs.
            date: Report date.
        
        Returns:
            List of Slack blocks.
        """
        blocks = self._build_slack_summary_blocks(jobs, date)
        
        if jobs:
            # Add top 5 jobs inline for webhook (can't thread)
            sorted_jobs = sorted(
                jobs, key=lambda j: j.semantic_score or 0, reverse=True
            )[:5]
            
            # Remove the thread hint block and replace with jobs
            # Find and remove the "See threaded replies" section
            blocks = [b for b in blocks if not (
                b.get("type") == "section" and 
                "threaded replies" in str(b.get("text", {}).get("text", ""))
            )]
            
            blocks.append({
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": "*ðŸ† Top 5 Opportunities*"
                }
            })
            
            # Add compact job list
            job_batch_blocks = self._build_job_batch_blocks(sorted_jobs, 1)
            blocks.extend(job_batch_blocks)
            
            if len(jobs) > 5:
                blocks.append({
                    "type": "context",
                    "elements": [
                        {
                            "type": "mrkdwn",
                            "text": f"_...and {len(jobs) - 5} more. See local report for full details._"
                        }
                    ]
                })
        
        return blocks
    
    def _send_slack_with_bot(
        self, 
        report: str, 
        jobs: list[Job], 
        date: datetime
    ) -> bool:
        """
        Send report to Slack using bot token with threaded job details.
        
        Posts a summary message, then replies with threaded messages
        containing batches of jobs (5 per thread).
        
        Args:
            report: The full markdown report (not used with threading).
            jobs: List of jobs in the report.
            date: The report date.
        
        Returns:
            True if successful.
        """
        slack_config = self.config.slack
        headers = {
            "Authorization": f"Bearer {slack_config.bot_token}",
            "Content-Type": "application/json",
        }
        
        with httpx.Client(timeout=30.0) as client:
            # Post the summary message first
            blocks = self._build_slack_summary_blocks(jobs, date)
            text = self._build_mention_text(jobs, date)
            
            msg_response = client.post(
                "https://slack.com/api/chat.postMessage",
                headers=headers,
                json={
                    "channel": slack_config.channel_id,
                    "text": text,
                    "blocks": blocks,
                }
            )
            
            if msg_response.status_code != 200:
                logger.error(f"Slack message failed: {msg_response.text}")
                return False
            
            result = msg_response.json()
            if not result.get("ok"):
                logger.error(f"Slack API error: {result.get('error')}")
                return False
            
            logger.info("Slack summary message posted")
            
            # Get the thread timestamp for replies
            thread_ts = result.get("ts")
            if not thread_ts:
                logger.warning("Could not get thread_ts for replies")
                return True  # Summary posted, just can't thread
            
            # Post threaded replies with job batches
            if jobs:
                sorted_jobs = sorted(
                    jobs, key=lambda j: j.semantic_score or 0, reverse=True
                )
                
                # Batch jobs into groups (configurable)
                batch_size = slack_config.jobs_per_thread
                for batch_num, i in enumerate(range(0, len(sorted_jobs), batch_size)):
                    batch = sorted_jobs[i:i + batch_size]
                    start_rank = i + 1
                    
                    thread_blocks = self._build_job_batch_blocks(batch, start_rank)
                    
                    thread_response = client.post(
                        "https://slack.com/api/chat.postMessage",
                        headers=headers,
                        json={
                            "channel": slack_config.channel_id,
                            "thread_ts": thread_ts,
                            "text": f"Jobs {start_rank}-{start_rank + len(batch) - 1}",
                            "blocks": thread_blocks,
                        }
                    )
                    
                    if thread_response.status_code == 200:
                        thread_result = thread_response.json()
                        if thread_result.get("ok"):
                            logger.debug(
                                f"Posted thread batch {batch_num + 1} "
                                f"(jobs {start_rank}-{start_rank + len(batch) - 1})"
                            )
                        else:
                            logger.warning(
                                f"Thread batch {batch_num + 1} error: "
                                f"{thread_result.get('error')}"
                            )
                    else:
                        logger.warning(
                            f"Thread batch {batch_num + 1} failed: "
                            f"{thread_response.status_code}"
                        )
                
                logger.info(
                    f"Posted {(len(sorted_jobs) + batch_size - 1) // batch_size} "
                    f"threaded replies with {len(sorted_jobs)} jobs"
                )
            
            return True
    
    def _build_slack_summary_blocks(
        self, 
        jobs: list[Job], 
        date: datetime
    ) -> list[dict]:
        """
        Build Slack blocks for the summary message (parent of thread).
        
        Args:
            jobs: List of jobs.
            date: Report date.
        
        Returns:
            List of Slack blocks.
        """
        blocks = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": f"ðŸŽ¯ Semantic Scout Report - {date.strftime('%B %d, %Y')}",
                    "emoji": True
                }
            },
            {
                "type": "divider"
            },
        ]
        
        if not jobs:
            blocks.append({
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": "ðŸ“­ No jobs scoring above the threshold were found today."
                }
            })
            return blocks
        
        # Summary stats
        avg_score = sum(j.semantic_score or 0 for j in jobs) / len(jobs)
        remote_count = sum(1 for j in jobs if j.is_remote)
        top_score = max(j.semantic_score or 0 for j in jobs)
        
        # Count by source
        by_source = {}
        for job in jobs:
            by_source[job.source] = by_source.get(job.source, 0) + 1
        source_text = " | ".join(
            f"{src.title()}: {cnt}" for src, cnt in sorted(by_source.items())
        )
        
        blocks.append({
            "type": "section",
            "fields": [
                {
                    "type": "mrkdwn",
                    "text": f"*ðŸŽ¯ Jobs Found:*\n{len(jobs)}"
                },
                {
                    "type": "mrkdwn",
                    "text": f"*ðŸ† Top Score:*\n{top_score:.1f}/10"
                },
                {
                    "type": "mrkdwn",
                    "text": f"*ðŸ“Š Avg Score:*\n{avg_score:.1f}/10"
                },
                {
                    "type": "mrkdwn",
                    "text": f"*ðŸ  Remote:*\n{remote_count}"
                }
            ]
        })
        
        blocks.append({
            "type": "context",
            "elements": [
                {
                    "type": "mrkdwn",
                    "text": f"ðŸ“ *Sources:* {source_text}"
                }
            ]
        })
        
        blocks.append({"type": "divider"})
        
        # Thread hint
        thread_count = (len(jobs) + 4) // 5  # Ceiling division
        blocks.append({
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": (
                    f"*ðŸ“‹ {len(jobs)} opportunities ranked by score*\n"
                    f"_See {thread_count} threaded replies below for full details_"
                )
            }
        })
        
        blocks.append({
            "type": "context",
            "elements": [
                {
                    "type": "mrkdwn",
                    "text": "Generated by *Semantic Scout* ðŸ”"
                }
            ]
        })
        
        return blocks
    
    def _build_job_batch_blocks(
        self, 
        jobs: list[Job], 
        start_rank: int
    ) -> list[dict]:
        """
        Build Slack blocks for a batch of jobs (threaded reply).
        
        Args:
            jobs: Batch of jobs to display.
            start_rank: The starting rank number for this batch.
        
        Returns:
            List of Slack blocks.
        """
        blocks = []
        
        for i, job in enumerate(jobs):
            rank = start_rank + i
            score = job.semantic_score or 0
            remote_badge = " ðŸ " if job.is_remote else ""
            
            # Score emoji based on value
            if score >= 9:
                score_emoji = "ðŸ”¥"
            elif score >= 8:
                score_emoji = "â­"
            elif score >= 7:
                score_emoji = "âœ¨"
            else:
                score_emoji = "ðŸ“‹"
            
            # Build job header
            job_header = f"*#{rank}* {score_emoji} *{job.title}*{remote_badge}"
            
            # Build details
            details_parts = [f"ðŸ¢ _{job.company}_"]
            
            if job.location:
                details_parts.append(f"ðŸ“ {job.location}")
            
            details_parts.append(f"Score: *{score:.1f}/10*")
            
            # Add matched city info
            if job.matched_city:
                if job.matched_city == "Remote":
                    pass  # Already shown via remote_badge
                elif job.matched_city == "Anywhere":
                    details_parts.append("ðŸŒ Anywhere")
                else:
                    distance_str = f" {job.distance_miles:.1f}mi" if job.distance_miles else ""
                    details_parts.append(f"ðŸ“Œ {job.matched_city}{distance_str}")
            elif job.distance_miles is not None and not job.is_remote:
                details_parts.append(f"({job.distance_miles:.1f} mi)")
            
            details_line = " â€¢ ".join(details_parts)
            
            job_text = f"{job_header}\n{details_line}"
            
            block = {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": job_text
                }
            }
            
            # Add link button if URL available
            if job.url:
                block["accessory"] = {
                    "type": "button",
                    "text": {
                        "type": "plain_text",
                        "text": "View Job â†’",
                        "emoji": True
                    },
                    "url": job.url,
                    "action_id": f"view_job_{rank}"
                }
            
            blocks.append(block)
            
            # Add AI reasoning if available
            if job.score_reasoning:
                # Truncate long reasoning
                reasoning = job.score_reasoning[:200]
                if len(job.score_reasoning) > 200:
                    reasoning += "..."
                
                blocks.append({
                    "type": "context",
                    "elements": [
                        {
                            "type": "mrkdwn",
                            "text": f"ðŸ’¡ _{reasoning}_"
                        }
                    ]
                })
            
            # Add divider between jobs (except after last)
            if i < len(jobs) - 1:
                blocks.append({"type": "divider"})
        
        return blocks
    
    def _build_mention_text(self, jobs: list[Job], date: datetime) -> str:
        """
        Build the fallback text with optional user mentions.
        
        Args:
            jobs: List of jobs.
            date: Report date.
        
        Returns:
            Text string with mentions.
        """
        slack_config = self.config.slack
        
        parts = []
        
        # Add mentions
        for user_id in slack_config.mention_users:
            parts.append(f"<@{user_id}>")
        
        # Add summary
        if jobs:
            parts.append(
                f"ðŸŽ¯ Semantic Scout found {len(jobs)} high-scoring opportunities "
                f"for {date.strftime('%B %d, %Y')}"
            )
        else:
            parts.append(
                f"ðŸ“­ No high-scoring jobs found for {date.strftime('%B %d, %Y')}"
            )
        
        return " ".join(parts)
